const express = require('express');
const axios = require('axios');
const router = express.Router();

/**
 * GitHub Security Bot Routes
 * Alternative approaches for suggesting security fixes
 */
const GITHUB_BASE_URL = 'https://api.github.com';
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

/**
 * Helper function to parse GitHub URL and extract owner/repo
 */
function parseGitHubUrl(url) {
  const regex = /github\.com\/([^/]+)\/([^/]+?)(?:\.git)?(?:\/.*)?$/;
  const match = url.match(regex);
  
  if (!match) {
    throw new Error('Invalid GitHub URL format');
  }
  
  let repo = match[2];
  // Remove .git suffix if present
  if (repo.endsWith('.git')) {
    repo = repo.slice(0, -4);
  }
  
  return {
    owner: match[1],
    repo: repo
  };
}

/**
 * Create a security vulnerability issue with suggested fixes
 * POST /api/github/create-security-issue
 * Body: {
 *   "url": "https://github.com/owner/repo",
 *   "vulnerability": {
 *     "title": "Security Vulnerability: SQL Injection in login.php",
 *     "severity": "HIGH", // LOW, MEDIUM, HIGH, CRITICAL
 *     "description": "Detailed vulnerability description",
 *     "affectedFiles": ["path/to/file.js"],
 *     "suggestedFix": "Code snippet or description of fix"
 *   }
 * }
 */
router.post('/create-security-issue', async (req, res) => {
  try {
    const { url, vulnerability } = req.body;

    if (!url || !vulnerability) {
      return res.status(400).json({
        success: false,
        error: 'GitHub repository URL and vulnerability details are required'
      });
    }

    if (!GITHUB_TOKEN) {
      return res.status(500).json({
        success: false,
        error: 'GitHub token not configured'
      });
    }

    // Parse GitHub URL
    let owner, repo;
    try {
      const parsed = parseGitHubUrl(url);
      owner = parsed.owner;
      repo = parsed.repo;
    } catch (parseError) {
      return res.status(400).json({
        success: false,
        error: 'Invalid GitHub URL format. Expected: https://github.com/owner/repo'
      });
    }

    // Create detailed issue body
    const issueBody = `
## ðŸ”’ Security Vulnerability Report

**Severity:** ${vulnerability.severity}

### Description
${vulnerability.description}

### Affected Files
${vulnerability.affectedFiles.map(file => `- \`${file}\``).join('\n')}

### Suggested Fix
\`\`\`
${vulnerability.suggestedFix}
\`\`\`

### Recommendations
- Review and test the suggested fix
- Consider implementing additional security measures
- Run security scans regularly

---
*This issue was automatically generated by a security analysis bot*
`;

    // Create the issue
    const issueResponse = await axios.post(
      `${GITHUB_BASE_URL}/repos/${owner}/${repo}/issues`,
      {
        title: vulnerability.title,
        body: issueBody,
        labels: ['security', 'vulnerability', vulnerability.severity.toLowerCase()]
      },
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecurityBot-HackThe6ix'
        }
      }
    );

    res.json({
      success: true,
      data: {
        issue: {
          number: issueResponse.data.number,
          title: issueResponse.data.title,
          url: issueResponse.data.html_url,
          state: issueResponse.data.state
        },
        repository: `${owner}/${repo}`,
        severity: vulnerability.severity
      }
    });

  } catch (error) {
    console.error('GitHub Security Issue Creation Error:', error.response?.data || error.message);
    
    if (error.response?.status === 404) {
      return res.status(404).json({
        success: false,
        error: 'Repository not found'
      });
    }

    if (error.response?.status === 403) {
      return res.status(403).json({
        success: false,
        error: 'Access denied. Repository may be private or issues may be disabled'
      });
    }

    res.status(500).json({
      success: false,
      error: 'Failed to create security issue',
      message: error.message
    });
  }
});

/**
 * Create a pull request with security fixes (improved version)
 * POST /api/github/create-security-pr
 * Body: {
 *   "url": "https://github.com/owner/repo",
 *   "vulnerability": {
 *     "title": "Fix: SQL Injection vulnerability",
 *     "description": "Detailed description of the fix",
 *     "severity": "HIGH"
 *   },
 *   "fixes": [
 *     {
 *       "file": "path/to/file.js",
 *       "changes": "new file content"
 *     }
 *   ]
 * }
 */
router.post('/create-security-pr', async (req, res) => {
  try {
    const { url, vulnerability, fixes } = req.body;

    if (!url || !vulnerability || !fixes || !Array.isArray(fixes)) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: url, vulnerability, and fixes array'
      });
    }

    if (!GITHUB_TOKEN) {
      return res.status(500).json({
        success: false,
        error: 'GitHub token not configured'
      });
    }

    // Parse GitHub URL
    let originalOwner, originalRepo;
    try {
      const parsed = parseGitHubUrl(url);
      originalOwner = parsed.owner;
      originalRepo = parsed.repo;
    } catch (parseError) {
      return res.status(400).json({
        success: false,
        error: 'Invalid GitHub URL format. Expected: https://github.com/owner/repo'
      });
    }

    // Get authenticated user info
    const userResponse = await axios.get(
      `${GITHUB_BASE_URL}/user`,
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecurityBot-HackThe6ix'
        }
      }
    );

    const forkOwner = userResponse.data.login;
    const branchName = `security-fix-${Date.now()}`;

    // Check if fork exists, create if not
    let forkExists = false;
    try {
      await axios.get(
        `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}`,
        {
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'SecurityBot-HackThe6ix'
          }
        }
      );
      forkExists = true;
    } catch (error) {
      if (error.response?.status !== 404) {
        throw error;
      }
    }

    if (!forkExists) {
      await axios.post(
        `${GITHUB_BASE_URL}/repos/${originalOwner}/${originalRepo}/forks`,
        {},
        {
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'SecurityBot-HackThe6ix'
          }
        }
      );
      // Wait for fork to be ready
      await new Promise(resolve => setTimeout(resolve, 3000));
    }

    // Sync fork with upstream (important for bots!)
    try {
      await axios.post(
        `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}/merge-upstream`,
        {
          branch: 'main'
        },
        {
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'SecurityBot-HackThe6ix'
          }
        }
      );
    } catch (syncError) {
      // Sync might fail if already up to date, that's okay
      console.log('Fork sync info:', syncError.response?.data?.message || 'Already up to date');
    }

    // Get latest commit SHA
    const branchResponse = await axios.get(
      `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}/branches/main`,
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecurityBot-HackThe6ix'
        }
      }
    );

    // Create new branch
    await axios.post(
      `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}/git/refs`,
      {
        ref: `refs/heads/${branchName}`,
        sha: branchResponse.data.commit.sha
      },
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecurityBot-HackThe6ix'
        }
      }
    );

    // Apply fixes
    for (const fix of fixes) {
      // Get current file SHA
      let currentSha = null;
      try {
        const fileResponse = await axios.get(
          `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}/contents/${fix.file}`,
          {
            headers: {
              'Authorization': `Bearer ${GITHUB_TOKEN}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'SecurityBot-HackThe6ix'
            },
            params: { ref: branchName }
          }
        );
        currentSha = fileResponse.data.sha;
      } catch (error) {
        // File might not exist, that's okay
      }

      // Update file
      const updateData = {
        message: `Security fix: ${vulnerability.title}`,
        content: Buffer.from(fix.changes).toString('base64'),
        branch: branchName
      };

      if (currentSha) {
        updateData.sha = currentSha;
      }

      await axios.put(
        `${GITHUB_BASE_URL}/repos/${forkOwner}/${originalRepo}/contents/${fix.file}`,
        updateData,
        {
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'SecurityBot-HackThe6ix'
          }
        }
      );
    }

    // Create PR with detailed security information
    const prBody = `
## ðŸ”’ Security Fix: ${vulnerability.title}

**Severity:** ${vulnerability.severity}

### Description
${vulnerability.description}

### Changes Made
${fixes.map(fix => `- Fixed \`${fix.file}\``).join('\n')}

### Security Impact
This fix addresses a ${vulnerability.severity.toLowerCase()} severity security vulnerability.

### Testing
Please review and test these changes thoroughly before merging.

---
*This pull request was automatically generated by a security analysis bot*
`;

    const prResponse = await axios.post(
      `${GITHUB_BASE_URL}/repos/${originalOwner}/${originalRepo}/pulls`,
      {
        title: `ðŸ”’ ${vulnerability.title}`,
        body: prBody,
        head: `${forkOwner}:${branchName}`,
        base: 'main'
      },
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecurityBot-HackThe6ix'
        }
      }
    );

    res.json({
      success: true,
      data: {
        pullRequest: {
          number: prResponse.data.number,
          title: prResponse.data.title,
          url: prResponse.data.html_url,
          state: prResponse.data.state
        },
        vulnerability: {
          title: vulnerability.title,
          severity: vulnerability.severity
        },
        filesFixed: fixes.length,
        branch: branchName
      }
    });

  } catch (error) {
    console.error('GitHub Security PR Creation Error:', error.response?.data || error.message);
    
    if (error.response?.status === 409) {
      return res.status(409).json({
        success: false,
        error: 'Conflict occurred. The repository may have been updated since analysis.',
        suggestion: 'Try running the analysis again with fresh data.'
      });
    }

    if (error.response?.status === 404) {
      return res.status(404).json({
        success: false,
        error: 'Repository not found or insufficient permissions'
      });
    }

    if (error.response?.status === 403) {
      return res.status(403).json({
        success: false,
        error: 'Access denied. Check your GitHub token permissions'
      });
    }

    res.status(500).json({
      success: false,
      error: 'Failed to create security pull request',
      message: error.message
    });
  }
});

module.exports = router;
